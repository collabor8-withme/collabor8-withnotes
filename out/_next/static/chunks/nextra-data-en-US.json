{"/computer-science-basics/computer-network/network":{"title":"网络概述","data":{"":"","什么是网络#什么是网络":"网络 = 结点 + 链路 就是说网络由节点和链路组成","结点-node#结点 Node":"交换机、路由器、主机等网络设备","链路-link#链路 Link":"网线、光纤等传输媒体","互连网-internet#互连网 internet":"互联网就是一个个的网络互联在一起，也叫做网络的网络。\nNetwork of Networks","因特网-internet#因特网 Internet":"最大的互联网","万维网-world-wide-web#万维网 World Wide Web":"因特网中的一项服务万维网（World Wide Web），通常简称为Web，是互联网上的一种信息服务系统。它由一系列互联的超文本文档（HyperText Documents）组成，这些文档通过互联网上的超文本链接（HyperLinks）相互关联，形成了一个庞大的全球信息网络。","统一资源定位符-url#统一资源定位符 URL":"URL是Uniform Resource Locator（统一资源定位符）的缩写，它是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。URL由多个部分组成，包括协议（例如HTTP、HTTPS、FTP等）、主机名（域名或IP地址）、端口号（可选）、路径、查询参数和片段标识等。URL是在浏览器中输入或点击的地址，使用户可以访问和定位特定的资源。\nhttps://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section1\n其中，https是协议，www.example.com是主机名，8080是端口号，/path/to/resource是资源的路径，param1=value1&param2=value2是查询参数，section1是片段标识。","超文本标记语言-html#超文本标记语言 HTML":"HTML是HyperText Markup Language（超文本标记语言）的缩写，是一种用于创建网页的标记语言。HTML使用标记（标签）来描述网页的结构和内容，包括标题、段落、列表、链接、图像等。网页浏览器解析HTML代码并将其呈现为用户可视的网页。HTML是互联网上网页的基础构建块，它和CSS（层叠样式表）一起被用于实现网页的外观和布局。\n<!DOCTYPE html>\n<html>\n<head>\n<title>My Webpage</title>\n</head>\n<body>\n<h1>Hello, World!</h1>\n</body>\n</html>","超文本传输协议-http#超文本传输协议 HTTP":"HTTP是HyperText Transfer Protocol（超文本传输协议）的缩写，是用于在计算机网络上传输超文本和其他资源的协议。HTTP是客户端-服务器协议，客户端（通常是Web浏览器）向服务器发送HTTP请求，服务器返回HTTP响应。它是构建在TCP/IP协议之上的应用层协议，用于在互联网上传输网页、图像、视频、文件等资源。"}},"/devops/server":{"title":"服务器","data":{"":"","什么是服务器#什么是服务器":"服务器就是一台计算机、就是一台电脑这台电脑一般没有显示设备（显示器）这台电脑一般还只会安装Linux操作系统（没有图形化操作界面的linux系统）图形化操作界面浪费性能、消耗资源","硬件层面来看#硬件层面来看":"从硬件层面来看，服务器是一种专门设计和配置的计算机，它旨在提供高性能、稳定性和可靠性，以满足处理大量数据和服务请求的需求。","软件层面来看#软件层面来看":"是指安装了某种服务器软件，通过这种服务器软件程序，提供某项服务的一台计算机。安装了Web服务器软件，通过这个Web服务器软件启动了一项服务，那么我们的这台电脑就可以称为 Web 服务器。那么这项服务是什么？就是万维网 www Web 服务\nURL\nHTTP\nHTML","服务器的操作系统#服务器的操作系统":"Linux\nUnix\nWindows Server","服务器软件种类#服务器软件种类":"Database服务器软件\nMySQL\nMongoDB\n\n\nMail服务器软件\nDNS服务器软件\nBIND\n\n\n代理服务器软件\nclash\nv2ray\n\n\nDHCP服务器软件\nSSH服务器软件\nFTP服务器软件\nvsftpd\n\n\n网页服务器/Web服务器软件\nApache（httpd）\nNginx（engine X）\nMicrosoft Internet Information Services（IIS）\nTomcat\nNetty\nTengine\n\n\n应用服务器软件"}},"/demo":{"title":"项目一极极极简版 --- JS包依赖分析工具","data":{"":"","提要#提要":"项目中的JS代码的运行在Nodejs 这个JavaScript运行时的，所以请先确保你的电脑安装的Nodejs以及npm、yarn、pnpm等包管理工具之一。","安装#安装":"全局安装（不推荐）\nnpm install -g @scoheart/cli-demo1\n\nyarn add -g @scoheart/cli-demo1\n项目安装（推荐）\nnpm install @scoheart/cli-demo1\n\n// or\nyarn add @scoheart/cli-demo1","使用#使用":"注意: 需要在项目的root path下（根路径）使用，也就是package.json所在的目录中运行下面的指令\nnpx scoheart\n\n// or\nyarn scoheart\n\n// or\npnpm scoheart\n之后打开终端里提示的URL地址，就可以见到项目中的依赖关系图。"}},"/programming-languages/python/grammar":{"title":"Grammar","data":{"":""}},"/programming-languages/overview/classification":{"title":"编程语言的分类","data":{"":"","按照编程技术难易程度分类#按照编程技术难易程度分类":"","高级语言#高级语言":"高级语言采用易于识别和记忆的字符来作为关键字，也更接近人类的思维方式，编写容易读写性好，开发效率更高。例如：\nC\nCpp\nJava\nPython\n\n\n越是高级的语言对人类越是友好，越是符合人类的思考方式，因此开发效率高。","低级语言#低级语言":"机器语言\n汇编语言\n\n\n越是低级的语言对机器越是友好，越是符合机器的思考方式，因此执行效率高。","按照编程范式分类#按照编程范式分类":"","面向过程语言#面向过程语言":"面向过程语言是以过程或函数为基础的，这种语言对底层硬件，内存等操作比较方便，但是写代码和调试维护等会很麻烦\nC","面向对象语言#面向对象语言":"面向对象语言（Object-Oriented Language）是一类以对象作为基本程序结构单位的程序设计语言，指用于描述的设计是以对象为核心，而对象是程序运行时刻的基本成分。语言中提供了类、继承等成分。\njava\nCpp","脚本语言#脚本语言":"脚本语言并不是一个明确定义的编程语言类型，而是一种用途广泛的编程语言，用于编写脚本以自动化任务或简化特定任务。很多解释型语言也被用作脚本语言。\npython\nshell\nphp\njavascript\nruby","函数式语言#函数式语言":"","逻辑编程语言#逻辑编程语言":"","按照用途分类#按照用途分类":"","通用目的编程语言#通用目的编程语言":"GPL General-Purpose Language 通用目的编程语言是一种设计用于解决广泛问题和任务的编程语言。它们在各种领域都有应用，并且可以用于开发各种类型的软件和应用程序\nPython\nJava\nC++\nC#\nJavaScrip\nRuby\nGo","领域特定语言#领域特定语言":"DSL Domain-Specific Language 领域特定语言是一种针对特定领域或问题域而设计的编程语言。它们专注于解决某个特定领域的问题，因此通常具有更高的表达能力和易用性，比通用目的编程语言在特定领域更有效。DSL 可以更接近于领域专家的自然语言，因此可以更容易地表达和解决特定问题。\nSQL (用于关系数据库查询)\nHTML/CSS (用于网页标记和样式)\nRegular Expression (用于字符串匹配)\nGraphQL (用于数据查询)\nMakefile (用于构建软件)\nLaTeX (用于排版科技文档)","按照执行方式分类#按照执行方式分类":"","解释型语言#解释型语言":"解释性语言是一种在运行时逐行解释并执行程序代码的语言。在解释性语言中，代码不需要预先编译成二进制代码，而是通过解释器逐行翻译成机器代码，并立即执行。解释性语言的代码可以直接在计算机上运行，而不需要先进行编译。每当程序运行时，解释器都会逐行解释代码，并将其转换为计算机可以理解的指令来执行。\npython\njavascript\nlua\nruby","编译型语言#编译型语言":"编译型语言是指在运行之前需要先将源代码编译成机器代码的语言。编译过程由编译器完成，它会将整个源代码转换成等价的机器代码文件（通常是二进制文件），然后可以直接在计算机上执行。编译型语言的运行速度通常较快，因为代码在执行之前已经被完整地翻译成机器代码\nC\nCpp\nGo\nRust","编译解释型语言#编译+解释型语言":"java","按照语言类型分类#按照语言类型分类":"","强类型#强类型":"强类型语言是指在编程过程中要求严格定义和处理数据类型的语言。在强类型语言中，变量的数据类型必须在声明时明确指定，并且不允许进行隐式类型转换。如果要进行类型转换，通常需要显式地进行类型转换操作。这种严格的类型检查能够提高代码的安全性和可靠性，但也可能需要更多的类型转换代码强类型语言，一旦一个变量被指定了某个数据类型，如果不经过强制类型转换，那么它就永远是这个数据类型。你不能把一个整形变量当成一个字符串来处理。\njava\nCpp","弱类型语言#弱类型语言":"弱类型语言是指对数据类型较为宽松，允许在一定程度上隐式地进行类型转换的语言。在弱类型语言中，变量的数据类型可以根据上下文进行自动推断或隐式转换，这样的特性可以方便开发者，但也可能增加代码出错的可能性。数据类型可以被忽略，一个变量可以赋不同数据类型的值。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型。\njavascript\npython2.x","动态类型语言#动态类型语言":"动态类型语言是指在运行期间才去做数据类型检查的语言，说的是数据类型，动态语言说的是运行是改变结构，说的是代码结构。动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。","静态类型语言#静态类型语言":"静态语言的数据类型是在编译其间确定的或者说运行之前确定的，编写代码的时候要明确确定变量的数据类型"}},"/devops/environment":{"title":"环境变量","data":{"":"","环境变量是什么#环境变量是什么":"他是存在系统内的一个全局变量","种类#种类":"","用户变量#用户变量":"专属与某个用户的全局变量","系统变量#系统变量":"所有用户都可以查看使用的全局变量环境变量有很多\nPATH\nHOME\n\n查看环境变量\nenv\n怎么去添加一个环境变量\n临时添加\n\n\nzhouxin=1234\nexport zhouxin\n\n永久添加\n\n\nroot用户的家目录\n/root/.bashrc\n/root/.bash_profile\n\nJAVA_HOME=/jdk/bin\nCLASS_HOME=/jdk\n\nPATH=$PATH:$JAVA_HOME:$CLASS_HOME\nexport PATH\n\nsource .bashrc\nip地址 = 网络号 + 主机号把主机号全为0 叫做那个网络00000000 00000000 00000000 00000000\n011111111 111111111 111111111 111111111\n\n\n\n192.168好记        juejin.cn\n正向代理\n反向代理\n\nweb\nURL\nHTML\nHTTP\n\n10.5.130.19510.0.0.0176.0.0.1\n192.168.1.10","js包管理器#js包管理器":"script       cdn 下载回来\nnpm\nyarn\npnpm\n\nlinux\nzsh\nbash\nshwindows\ncmd\npowershellmacos 类UNIX\nzsh\nbash\nsh可执行文件环境变量"}},"/":{"title":"Index","data":{"":"","#":"比如假设我现在有一家企业 想为我的企业做一个网站\n我提出了这个要创网站的需求\n产品经理根据我的需求设计了项目原型\n再通过UI设计师设计出漂亮的界面，形成UI设计图\n前端开发者根据UI设计图来通过前端技术(html css js等)来 把UI设计图通过代码实现成网页(所以前端开发者又被亲切的叫做”切图崽”)\n后端开发者来实现一些数据的业务逻辑，并且可能同时还要兼顾数据库的设计。(所以后端开发者又被亲切的叫做”就是搞CRUD的”)\n数据库设计管理也可能由专门的人员负责\n前端开发者和后端开发者要一起定义接口规范(后面开发过程中，前后端扯皮吵架的一大重点)\n测试人员完成对代码的测试\n运维人员部署项目\n项目上线\n\nhttp://localhost:8080/testJSON\n{\n\"name\": \"shuhso\",\n\"age\": 12,\n\"addr\": \"hunan\",\n\"QQ\": \"qq\"\n}\n前后端不分离的时代     服务端渲染      多页面MPA\nhttps://www.baaaaa.comindex.html\napple.html前后端分离      客户端渲染      单页面       的网站\nhttps://www.baaaaa.comindex.html执行js脚本     ---》 发起AJAX异步请求   ---》 从后端拿数据（JSON格式的数据）\nXHR\nfetch\nAxios\n\n把JSON格式的数据变成  --》   JS对象     ---〉DOM API挂载到页面上 --》浏览器渲染出来\ndocument.qs(\"#app\").innerHTML = person.name","-1#":"然后 就是说 一个网站的发展历史是什么样的---最开始 就是静态内容网页\n什么是静态网页呢？\n静态网页就是数据或者说展示的东西就是固定的，每个人访问这个网站看到的都是一样的东西，这些展示的东西，都是写死在了HTML的标签内容里面--- 后来，动态内容网页出现，那么同时还处于前后端不分离的开发时代\n什么是动态网页呢？\n动态网页就是数据或者说展示的东西就是不固定的，这些展示的数据，就不是写死在了HTML的标签内容里，而是通过一种模板引擎，或者一些变量，来控制里面的内容。\n前后端不分离\n因为还没有AJAX这一类的技术出现，所以要实现这种数据可以被替换，而不是写死在HTML里，那么，只能靠在服务端实现，类比于JSP、PHP这种技术，就是说把数据放到页面上的过程，最终是在服务端实现的。这里就有一个概念，叫做服务端渲染。\n\n--- 服务端渲染 客户端渲染--- 再后来，AJAX出现。前后端分离的时代到来\n什么是AJAX，以及前后端分离？\nAJAX可以理解成一种规范，全称Asynchronous JavaScript And XML，AJAX的出现，是为了实现我们网页的部分更新，同时是在这个时候我们的前后端的数据通信，是通过XML实现的，而不是现在的JSON。前后端分离就是说，现在界面依然是动态网页，但是数据不是在服务器端渲染上去的，而是通过AJAX拿到服务端的数据，并且数据的传输格式是XML（或者现在的JSON），再在客户端（浏览器之类的）渲染上去的。--- MPA SPA 那么还有多页面 单页面的概念","网站发展#网站发展":"","静态内容网页#静态内容网页":"不会变的，内容写死在html里面","动态内容网页#动态内容网页":"","前后端不分离-服务端渲染#前后端不分离 服务端渲染":"会变的，内容根据情况而言","ajax出现-前后端分离-客户端渲染#AJAX出现 前后端分离 客户端渲染":"不要把AJAX理解为一项具体的技术，而是当成一种规范来看待\nAsynchronous JavaScript And XML\n通过JavaScript的异步操作 和 XML格式的文件 来实现前后端的数据传输实现AJAX这种规范的技术有很多\nXHR      XMLHttpRequest对象的简称\n$.ajax()          JQuery这个库的AJAX实现   XMLHttpRequest的封装\naxios             axios这个库就是对XMLHttpRequest对象的封装、基于Promise\nfetch            基于Promise的异步请求模块\n\n后端使用java的Web框架写的 Java对象\nAsynchronous JavaScript And XMLAsynchronous JavaScript And JSON\nXML数据格式\n缺点： 麻烦\n\n\n<person>\n<name>shuhao</name>\n<age>12</age>\n</person>\nJSON数据格式\n{\n\"person\": {\n\"name\": shuhao,\n\"age\": 12\n}\n}\n前端是用js js对象","mpa-multi-page-application#MPA multi Page application":"每一个页面都有一个单独的HTML文件","spa-single-page-application#SPA single Page Application":"路由机制网站有很多界面\n多个html\n单独一个html + 路由机制","服务器#服务器":"就是一台电脑，安装服务器软件之后，启动某一项服务，他就可以被称为服务器。\nTomcat\nApache\nNginx","一般服务器会安装的os-操作系统#一般服务器会安装的OS 操作系统":"服务器一般不会用MacOS Windows 因为他们两个有图形化界面\n图形化界面 很吃资源linux 一般没有图形化操作界面\nwindows server","服务器软件会干嘛#服务器软件会干嘛":"启动这个服务器软件之后，他会在这台电脑上，启动一个进程，这个进程会跑在一个端口上127.0.0.1   ===   localhost   这个ip 是指向自己电脑8080127.0.0.1:8080/index.html","总结#总结":"服务器\n一台电脑\n安装linux系统\n安装服务器软件","web服务器#web服务器":"一台电脑\n安装linux系统\n安装服务器软件 --- web服务器软件","服务端#服务端":"这台电脑上\n启动了一个服务器软件Tomcat\nTomcat服务器软件开起了一个进程\n这个进程监听了8080端口 http tcp\n\nhttp://localhost:8080/demo/test","跨域#跨域":"http://localhost:8080/demo/testhttp://192.168.1.1:8080\nURL","网络#网络":"什么是网络？\n网络 = 节点 + 链路\n节点你可以理解为 电脑\n链路你可以理解为 网线","互联网#互联网":"一个 又 一个的网络通过链路（网线）连在一起 就是互联网","因特网#因特网":"是世界上最大的互联网","万维网-world-wide-web-就是www#万维网 World Wide Web （就是www）":"是因特网中的一个服务，你访问的www.baidu.com\nwww就是代表他是一个Web服务万维网又有三个重要的东西\nHTML       用来保存内容\nURL           用来定位这个内容在哪里\nHTTP         传输这个内容的协议\n\ngit github pr issue git团队开发项目html  cssjs dom 2个月js 基础语法事件循环\n浏览器渲染原理\n异步编程节省时间 crash course需求分析Web开发  提供Web服务 万维网服务 通过在一台电脑上安装 Web服务器软件 来提供Web服务 让你访问超文本文档（HTML URL HTTP）\n原型设计 产品经理       蓝湖\nUI设计师 网页设计图       figma\n定义接口规范       接口文档\n并发  电商秒杀        1亿      javaEE          Tomcat、netty、undertown\n前端 html css  js       Vue React Svelte Solid  切图仔\n后端  java Spirng   SpringBoot       生态好         go     Gin       Web框架\nCRUD\n读源码\n增删改查\nFull stack 全栈    架构师\npython             django  、flask\njs           nestjs        koa        express      egg\n数据库           SQL        MySQL\n测试人员\n运维人员    linux开源 分享黑马 尚硅谷\n开源社区","静态内容网页-1#静态内容网页":"把内容直接写着HTML标签里","动态内容网站#动态内容网站":"","前后端不分离服务端渲染#前后端不分离(服务端渲染)":"HTML标签里没有直接写内容，而是通过模板引擎（jsp、php、asp）替换js 的模块引擎（ejs）","前后端分离-ajax-客户端渲染#前后端分离 AJAX （客户端渲染）":"基础语法\n异步编程\n事件循环\n浏览器渲染原理\n回调函数\nPromise\nAsync Await\nAJAX 异步数据请求","-2#":"DOM API             js 去操作html代码\n同步\n\nwebpack\nrollup立即执行函数  闭包\n异步\n\nAJAXAsynchronous JavaScript And JSON 规范ECMAScript\njavascriptfetch\naxios\n$.ajax\nXHRXML缺点\n<name>shuhao</name>\n<age>12</age>\n\n{\n\"name\": \"shuhao\",\n\"age\": 12\n}\n前端 --》 AJAX --〉后端 --》 数据库\njs\nJSON         SQL\n前端 AJAX JSON  后端    SQL    关系型数据库MySQL\nORM\n数据库的对象 --》 JAVA对象\nJAVA对象——XML对象\nXML ---- JS对象js对象的值    DOM API    挂在DOM HTML事件循环面向对象\n封装            闭包\n继承            ES5 类              原型 原型链       ES6 类《--  原型 原型链\n多态"}},"/web-development/frontend/js-runtime/browser/browser":{"title":"浏览器","data":{"":"","进程#进程":"每开启一个软件，就会启动一个进程，这个进程会监听一个端口","线程#线程":"一个进程开启，他可能会启动多个线程","浏览器架构演变#浏览器架构演变":"单进程架构\n多进程架构\n面向服务架构","多进程模型#多进程模型":"主进程\n渲染进程\n每开启一个tab页面就会开启一个渲染进程\nGPU进程\n网络进程\nPlugins进程\n\n\n进程名\t进程作用\t主进程\t主要负责页面展示逻辑、用户交互、子进程管理；包括地址栏、书签、前进、后退、收藏夹等\tGPU进程\t负责UI绘制、包含整个浏览器的全部UI\t网络进程\t网络服务进程、负责网络资源加载\t渲染进程\t控制Tab内的所有内容，将HTML、CSS和JavaScript转换为用户可交互的网页\t插件进程\t控制网站运行的插件、比如flash等\t其他进程\tStorage、Network、Audio Service等","浏览器内核-渲染进程#浏览器内核 （渲染进程）":"Trident\nGecko\nWebkit\nBlink\nPresto\n\n\n内核\t浏览器\tJS引擎\tTrident\tIE4-11\tJScript、Chakra\tGecko\tFirefox\tSpiderMonkey\tWebkit\tSafari、Chrome、Android浏览器\tJavaScriptCore\tBlink\tChrome、Opera\tV8\tEdge\tEdge\tChakra\tTrident+Webkit(Blink)\t国产浏览器，QQ、360、搜狗、UC等等\t都有都有","多线程模型针对渲染进程#多线程模型（针对渲染进程）":"GUI渲染主线程\njs引擎线程\n事件触发线程\n定时器触发线程\n网络线程\n\n\n线程\t功能\tGUI渲染主线程\t负责渲染浏览器界面，解析HTML、CSS，构建DOM树、Render树，布局，绘制，和js引擎互斥\tJS引擎线程\t负责解析JS脚本，运行JS程序，每个渲染进程下只有一个JS引擎线程。与GUI渲染主线程互斥，如果执行任务过长，会导致页面卡顿\t定时器触发线程\tsetTimeout、setInterval计时完毕后，将回调添加到事件队列，等待JS引擎执行\t网络线程\tXHR、fetch发起请求后开启一个网络线程请求，如果设置了回调函数、在状态变更时候，将回调函数放入事件队列，等待JS引擎执行\t事件触发线程\t宿主环境提供，用于控制事件循环，不断地从事件队列取出任务执行","gui渲染引擎#GUI渲染引擎":"CRP Critical rendering path 关键渲染路径\n解析HTML & CSS源码\n解析HTML --> XML解析器\n解析CSS --> CSS解析器\n\n\n构建DOM树 & CSSOM树\nHTML --> DOM树\nCSS --> CSSOM树\n\n\n构建Render树/Layout树\n布局 Layout\n分层 Layer\n绘制 Paint\n展示 Display","js引擎#JS引擎":"解析JS源码 --> JS解析器\n转化成AST\n翻译成字节码\n解析执行字节码\nJIT 转化成机器码\n直接执行机器码"}},"/web-development/frontend/js-runtime/browser/event-loop":{"title":"Event Loop","data":{"":"![[Pasted image 20230731151756.png]]\nsetTimeout(function() {\nconsole.log(1)\n}, 0);\n\nnew Promise(function executor(resolve) {\nconsole.log(2);\nfor( var i=0 ; i<10000 ; i++ ) {\ni == 9999 && resolve();\n}\nconsole.log(3);\n}).then(function() {\nconsole.log(4);\n});\nconsole.log(5);\n\n\nsetTimeout(() => {\nnew Promise(resolve => {\nresolve();\n}).then(() => {\nconsole.log('test');\n});\nconsole.log(4);\n});\n\nnew Promise(resolve => {\nresolve();\nconsole.log(1)\n}).then(() => {\nconsole.log(3);\nPromise.resolve().then(() => {\nconsole.log('before timeout');\n}).then(() => {\nPromise.resolve().then(() => {\nconsole.log('also before timeout')\n})\n})\n})\nconsole.log(2);\n\n\nconsole.log(1)\nconsole.log(2);\nconsole.log(3);\nconsole.log('before timeout');\nconsole.log('also before timeout')\nconsole.log(4);\nconsole.log('test');\n\n\n\n\nmicro\nconsole.log('test');\nconsole.log(3);\nPromise.resolve().then(() => {\nconsole.log('before timeout');\n}\nconsole.log('before timeout');\n\n\nmacro\nconsole.log(4);\n\nsetTimeout(function() {\nconsole.log(0);\n});\n\nnew Promise((resolve, reject) => {\nconsole.log(1);\nresolve();\n}).then(() => {\nconsole.log(2);\nnew Promise((resolve, reject) => {\nconsole.log(3);\nresolve();\n}).then(() => {\nconsole.log(4);\n}).then(() => {\nconsole.log(5);\n});\n}).then(() => {\nconsole.log(6);\n});\n\nnew Promise((resolve, reject) => {\nconsole.log(7);\nresolve();\n}).then(() => {\nconsole.log(8);\n});\n\n\nconsole.log( \"1\" )\n\nsetTimeout(function() {\nconsole.log( \"2\" )\n}, 0 )\n\nsetTimeout(function() {\nconsole.log( \"3\" )\n}, 0 )\n\nsetTimeout(function() {\nconsole.log( \"4\" )\n}, 0 )\n\nconsole.log( \"5\" )\n\n// 输出顺序 1，5, 2, 3, 4\n\nsetTimeout(function(){\nconsole.log('1')\n});\n\nnew Promise(function(resolve){\nconsole.log('2')\nfor(var i = 0; i < 10000; i++){\ni == 99 && resolve()\n}\n}).then(function(){\nconsole.log('3')\n});\n\nconsole.log('4')\n\n// 输出顺序 2，4, 3, 1\n\nconsole.log('1')\n\nasync function async1() {\nawait async2()\nconsole.log('2')\n}\n\nasync function async2() {\nconsole.log('3')\n}\n\nasync1()\n\nsetTimeout(function() {\nconsole.log('4')\n}, 0)\n\nnew Promise(resolve => {\nconsole.log('5')\nresolve()\n})\n.then(function() {\nconsole.log('6')\n})\n.then(function() {\nconsole.log('7')\n})\n\nconsole.log('8')\n\n// 输出顺序 1，3，5，8，2，6，7，4\n\nWordpressSSG  Static Site GeneratorCMS 内容管理系统jamstack\nSSG      前台展示\nheadless CMS      后台管理Wordpress\n掌握HTML、CSS能够使用、、布局还原设计稿\n掌握JavaScript，等知识、以及ES6、\n掌握js的运行时、nodejs的使用，以及浏览器的一些原理\n了解TypeScript、flow等等\n掌握JS包管理工具npm、yarn、pnpm。了解单仓库多模块管理monorepo。\n了解前端工程化，构建工具。例如linter工具、基于任务流的grunt、gulp、以及模块打包工具webpack、rollup、vite、esbuild\n掌握Vue React等前端框架，知道MVVM、MVP、MVC这种架构思想\n掌握前端状态管理机制，以及了解SPA和前端路由机制。\n掌握Nuxt Nextjs等全栈框架\n熟悉前后端交互原理，了解JS异步编程以及JSON格式、AJAX axios fetch\n\nmini-axios\n读了axios源码，自己实现的一个前端请求库？create-vite\n自己创建的前端项目脚手架？cli一个项目发布到npmmonorepo"}},"/web-development/frontend/js/es/es2015/let":{"title":"Let","data":{"":"","let-声明块变量#let 声明块变量":"let declarations are scoped to blocks as well as functions.\nlet 声明的作用域为块和函数。\nlet declarations can only be accessed after the line of declaration is reached (see temporal dead zone). For this reason, let declarations are commonly regarded as non-hoisted.\nlet 声明只能在到达声明行后才能访问（请参阅临时死区）。因此， let 声明通常被视为非提升声明。\nlet declarations do not create properties on globalThis when declared at the top level of a script.\n在脚本顶层声明时， let 声明不会在 globalThis 上创建属性。\nlet declarations cannot be redeclared by any other declaration in the same scope.\nlet 声明不能被同一范围内的任何其他声明重新声明。\nlet begins declarations, not statements. That means you cannot use a lone let declaration as the body of a block (which makes sense, since there's no way to access the variable).\nlet 开始声明，而不是语句。这意味着您不能使用单独的 let 声明作为块的主体（这是有道理的，因为无法访问该变量）。"}},"/web-development/frontend/js/es/es2015/this":{"title":"This","data":{"":""}},"/web-development/frontend/js/es/es2016/Untitled":{"title":"Untitled","data":{"":""}},"/web-development/frontend/js/es/es2015/execution context":{"title":"Execution Context","data":{"":"全局\n函数\neval\nmodules","全局#全局":"Browser 环境           Scope\nScript\nGlobal -- Window\n\n使用var定义的变量会直接在Global上\n使用let const定义的变量就会在Script上然后查找变量的顺序是从 Script --》Global","作用域#作用域":"作用域就是当前的执行上下文"}},"/web-development/frontend/js/es/es2015/closures":{"title":"Closures","data":{"":"In JavaScript, closures are created every time a function is created, at function creation time.","block-scope#block scope":"ES5 没有块级作用域下面的{}不会创建块作用域，实际上需要报错，但是却可以访问到x这个变量\nif (Math.random() > 0) {\nvar x = 1;\n} else {\nvar x = 2;\n}\n\nconsole.log(x)\ntemporal dead zones  & let constES6虽然可以把{}变成块级作用域，但是变量声明必须用 const let那么实际上是const let创建作用域\nif (Math.random() > 0.5) {\nconst x = 1;\n} else {\nconst x = 2;\n}\nconsole.log(x);   // ReferenceError: x is not defined\nES module 也是块作用域","closures#closures":"A closure is the combination of a function and the lexical environment within which that function was declared词法环境相同的闭包\nfunction makeFunc() {\nconst name = \"Mozilla\";\nfunction displayName() {\nconsole.log(name);\n}\nreturn displayName;\n}\n\nconst myFunc = makeFunc();\nmyFunc();\n\n词法环境不同的闭包\nfunction makeAdder(x) {\nreturn function (y) {\nreturn x + y;\n};\n}\n\nconst add5 = makeAdder(5);\nconst add10 = makeAdder(10);\n\nconsole.log(add5(2)); // 7\nconsole.log(add10(2)); // 12","practical-closures#practical closures":"function makeSizer(size) {\nreturn function () {\ndocument.body.style.fontSize = `${size}px`;\n};\n}\n\nconst size12 = makeSizer(12);\nconst size14 = makeSizer(14);\nconst size16 = makeSizer(16);","emulating-private-methods-with-closures#Emulating private methods with closures":"使用闭包模拟私有方法"}},"/web-development/frontend/js/runtime":{"title":"以Runtime重新认知JavaScript","data":{"":"","javascript语言的执行方式#JavaScript语言的执行方式":"解释型语言 --> 解释器","js-runtime-运行环境-解释器#JS Runtime 运行环境 解释器":"Browser\n谷歌浏览器    V8\n火狐浏览器    SpiderMonkey\nIE浏览器\nEdge浏览器\n国产浏览器\n\n\nNodejs\nV8\n\n\nDeno\nBun","如何去执行一句代码#如何去执行一句代码":"","browser#Browser":"控制台里面直接输入代码","nodejs#Nodejs":"进入到node环境，直接输入代码","如何去执行单个js代码文件#如何去执行单个js代码文件":"","nodejs-1#Nodejs":"node index.js","browser-1#Browser":"通过HTML的一个标签 script 去引入js文件","在runtime基础上划分js为三部分#在Runtime基础上，划分js为三部分":"ECMAscript\n内置的API\nBrowser APIs\nDOM API\nBOM API\n\n\nNodejs APIs\nfs模块\nhttp模块\npath模块\n\n\n\n\n外置的API、外部库\naxios\nlodash\njquery"}},"/web-development/frontend/other/cli":{"title":"如何开发CLI项目","data":{"":"那么其实CLI项目是通过node环境来运行JavaScript代码的，所以我们就需要在node环境下开发项目"}},"/web-development/frontend/js/es/es2015/memory":{"title":"内存空间","data":{"":"","值传递#值传递":"","值类型#值类型":"开辟一块新的内存地址，复制粘贴数据进去","引用类型#引用类型":"原本的变量就保存的是地址，指向另一个内存空间\n开辟一块新的内存地址，复制粘贴地址进去"}},"/web-development/other/web":{"title":"网页发展史","data":{"":"","静态内容网页#静态内容网页":"所有的内容都是预习写好在了HTML中，不会改变","动态内容网页#动态内容网页":"","前后端不分离#前后端不分离":"","template-engine-模版引擎#Template Engine 模版引擎":"Java\nVelocity\nJSP\nFreemarker\nThymeleaf\n\nJavaScript\nEJS\n\n通过将模板引擎中定义的特定模版转化成HTML字符串 最终返回给浏览器","ssr-服务端渲染#SSR 服务端渲染":"Server Side Rendering\n通过将模板引擎中定义的特定模版转化成HTML字符串是发生在服务端的在浏览器（客户端）拿到的就是完整的HTML（完整的网页）","router-后端路由#Router 后端路由":"Back End Router","mpa-多页面应用#MPA 多页面应用":"Multiple Page Application\n一个页面就是一个html","前后端分离#前后端分离":"","ajax#AJAX":"Asynchronous JavaScript And XML\n实现网页中的部分刷新通过JavaScript的异步编程 以及 XML的文件传输格式，实现前后端交互","csr-客户端渲染#CSR 客户端渲染":"Client Side Rendering\n最初浏览器拿到的只是一个空白的HTML文件，然后通过解析执行JS文件，通过AJAX发起异步请求获取数据，将数据放入视图后，再调用DOM API将视图挂载到页面上。","router-前端路由#Router 前端路由":"Front End Router\n\nhash路由\nhistory路由","spa-单页面应用#SPA 单页面应用":"Single Page Application\n一个网站只有一个html文件，最终的页面切换是通过前端路由以及AJAX来实现的异步刷新","访问顺序#访问顺序":"","静态网页访问顺序#静态网页访问顺序":"浏览器 --》Web服务器（返回的就是完整的HTML、CSS、JS）","动态网页访问顺序#动态网页访问顺序":"","前后端不分离-1#前后端不分离":"浏览器 --》Web服务器（模版引擎利用服务端渲染构成完整的HTML，返回的就是完整的HTML、以及CSS、JS）","前后端分离-1#前后端分离":"浏览器 --》前端服务器 （拿回来不完整的HTML，以及CSS、JS）\n<!DOCTYPE html>\n\n<html lang=\"\">\n<head>\n<meta charset=\"utf-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n<link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n<title><%= htmlWebpackPlugin.options.title %></title>\n</head>\n<body>\n<div id=\"app\"></div>\n</body>\n\n</html>\n浏览器执行JS脚本 --》 发起AJAX请求 --〉后端服务器拿数据 （JSON）浏览器拿到数据 --》 执行JS脚本 --〉把数据放入视图中 --》 通过DOM API 渲染视图"}},"/web-development/other/cross":{"title":"Cross-","data":{"":"把所谓的跨xxx，我理解为两种","跨平台#跨平台":"Cross-Platform\n我把这种理解为跨 操作系统\n\n跨平台应用开发框架，如React Native、Flutter和Xamarin，允许使用一套代码构建同时运行在多个平台（如iOS和Android）上的移动应用程序。\n跨平台的Web技术，如HTML、CSS和JavaScript，可以通过Web浏览器在不同的操作系统上运行。\n虚拟机技术，如Java虚拟机（JVM）和.NET Framework，使得使用Java或C#等编程语言编写的应用程序可以在多个平台上运行。","electron-框架#electron 框架":"基于JavaScript的框架 Electron 可以开发不同操作系统的桌面端应用","docker#Docker":"Docker可以跑在不同的操作系统上","react-native#React Native":"RN可以基于React开发IOS、Android的移动端应用","java-和-c#Java 和 C#":"java通过JVM实现在不同操作系统中运行代码\nC#使用.NET实现在不同操作系统中运行代码","跨端跨设备#跨端（跨设备）":"Cross-Device\n跨端是指软件、应用程序或服务可以在不同类型的设备上运行，而不仅仅局限于某一类设备。跨端技术是能够在多种不同设备上运行的技术。这些设备包括桌面计算机、移动设备（如智能手机和平板电脑）、物联网设备以及其他智能终端。\n响应式Web设计：通过使用HTML5和CSS3等技术，使得网站能够自动适应不同屏幕尺寸和设备类型，从而在桌面和移动设备上都能提供良好的用户体验。\n响应式移动应用设计：类似于响应式Web设计，通过使用适配不同屏幕尺寸和分辨率的技术，使得移动应用在不同移动设备上能够适应和展现出最佳效果。\n云服务：将数据和应用程序存储在云端，使得用户可以在不同设备上访问和同步数据，无论是在移动设备上还是在桌面设备上。"}},"/web-development/frontend/js/modularization":{"title":"JavaScript的模块化开发","data":{"":"","what-is-javascript-module#What is javascript module":"例如实现一个web的计算器，我们需要划分不同模块\n主运行模块\n加法模块\n减法模块","原始的模块化开发#原始的模块化开发":"通过script标签引入不同模块\n顺序的问题\n变量作用域的","namespace#Namespace":"命名空间","iife--closures#IIFE & Closures":"immediately invoked function expression & Closures 立即执行函数和闭包","commonjs#CommonJS":"Nodejs这个runtime的横空出世，带来了Nodejs自己的模块化解决方案，CommonJS是一种模块化规范，用于在服务器端和本地环境中实现模块化编程。它主要用于Node.js环境。\nrequire 模块导入\nmodule.exports 模块导出\n\n\n那么Browser Runtime才是主流的JavaScript Runtime，所以社区形成了一些可行的针对于Browser Runtime的模块化方案","amd#AMD":"Asynchronous Module Definition 异步模块定义\nAMD也是一种模块化规范，用于在浏览器环境中实现异步加载模块。它主要由RequireJS等库来支持。\nRequireJS","cmd#CMD":"Common Module Definition 通用模块定义\nCMD也是一种模块化规范，类似于AMD，但它更强调按需加载模块。SeaJS是一个支持CMD的库。\nSeaJS","umd#UMD":"Universal Module Definition 通用模块定义\nUMD是一种通用的模块化规范，旨在兼容CommonJS和AMD，并且可以在浏览器和Node.js环境中使用。","esm#ESM":"ECMAScript ModulesESM是ECMAScript（JavaScript）的官方模块化规范，从ES6/ES2015开始引入。它支持静态导入和导出，并成为JavaScript开发中的主要模块化标准。","使用esm的前提#使用ESM的前提":"script标签上添加一个属性 type 属性值为 module\n打开HTML文件的时候，不可以使用file","esm的使用#ESM的使用":"一个文件就是一个模块如何导入一个模块\nimport\n\n如何导出模块中的变量、函数……\nexport","导出方式#导出方式":"named export\nexport var a = 1111\n\nexport function fn() {\n\n}\n\nexport var obj = {\n\n}\n\ndefault export\n在每一个js模块中只能用一次\nlet str = 'scoheart';\n\nexport default str;","导入方式#导入方式":"导入所有的东西\nnamed export\ndefault export\n\n\nimport * as Module from '......js'\n导入default\nimport module from '.....js'\n导入named\nimport {name1, name2} from '.....js'","总结#总结":"用什么样的模块化导出\n在导入的时候就要安装一样的模块化规范导入Commonjs\nmodule.exports = {\n\n}\n\nconst a = require(\"\")\nESM\nexport default Vue;\n\nimport Vue from \"xx.js\"\namd\\cmd\ndefine()\numd\nIIFE + Closures 导出\n\nglobalThis\n\nglobalThis.Vue\n\nconsole.log(Vue)"}},"/web-development/frontend/js/es/es2015/iife":{"title":"Iife","data":{"":"新建立了一个github仓库，这个仓库使用了React的渲染框架Nextjs 封装而成的一套静态站点生成框架（SSG）Nextra。同时，已经部署到Vercel，变成了一个Web网页。我们可以把每一天学习的笔记、感想都放在这个项目中，然后展示在网页上方便查看。以及我们会一起通过Git工作流来实现对这个项目仓库的管理。我们可以提Issue、PR来对别人的文章进行修改提议、完善提议等等。类似于一个开源项目一样，不过我们的项目是一个博客项目而已。同时，我们最终的大项目，无论选择项目几，开发的流程也是按照这种方式执行。所以，希望大家在这个过程中，学会如何使用Git，认知到Git的工作流，了解Git的团队合作开发以及对Github使用熟悉，乃至最后能够以后实现对其他的大开源项目提Issue，提PR。下面是项目网站地址：collabor8-withnotes.vercel.app昨天的两篇文章记录地址：\nhttps://collabor8-withnotes.vercel.app/web/frontend/js/modularizationhttps://collabor8-withnotes.vercel.app/web/frontend/js/runtime"}}}